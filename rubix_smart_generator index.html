<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur Rubix - Interface Adaptative</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Trebuchet MS', sans-serif;
            background: #f0f2f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        .panel {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #FFD700;
        }
        
        .logo {
            font-size: 32px;
            font-weight: 900;
            color: #051E50;
            letter-spacing: 1px;
        }
        
        .logo-x {
            color: #FFD700;
        }
        
        h1 {
            font-size: 24px;
            color: #051E50;
            font-weight: 700;
        }
        
        h2 {
            font-size: 18px;
            color: #051E50;
            margin: 25px 0 15px 0;
            font-weight: 700;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #051E50;
            font-weight: 600;
            font-size: 14px;
        }
        
        .label-hint {
            font-weight: 400;
            color: #666;
            font-size: 12px;
            margin-top: 4px;
        }
        
        input[type="text"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Trebuchet MS', sans-serif;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #FFD700;
        }
        
        textarea {
            resize: vertical;
            min-height: 150px;
        }
        
        .radio-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .radio-option {
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
            text-align: center;
        }
        
        .radio-option input[type="radio"] {
            display: none;
        }
        
        .radio-option:hover {
            border-color: #FFD700;
            transform: translateY(-2px);
        }
        
        .radio-option input[type="radio"]:checked + label {
            font-weight: 700;
        }
        
        .radio-option.selected {
            border-color: #FFD700;
            background: #fffbf0;
        }
        
        .radio-label {
            font-size: 32px;
            display: block;
            margin-bottom: 5px;
        }
        
        .radio-text {
            font-size: 14px;
            font-weight: 600;
            color: #051E50;
        }
        
        .generate-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #051E50 0%, #0a3d80 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
        }
        
        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(5, 30, 80, 0.3);
        }
        
        .generate-btn:active {
            transform: translateY(0);
        }
        
        .preview-panel {
            position: sticky;
            top: 20px;
            height: fit-content;
        }
        
        .preview-canvas {
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            background: white;
        }
        
        .download-btn {
            width: 100%;
            padding: 15px;
            background: #FFD700;
            color: #051E50;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s;
        }
        
        .download-btn:hover {
            background: #ffd000;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(255, 215, 0, 0.3);
        }
        
        .info-box {
            background: #e8f4ff;
            border-left: 4px solid #051E50;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #051E50;
        }
        
        .tip-box {
            background: #fffbf0;
            border-left: 4px solid #FFD700;
            padding: 12px;
            border-radius: 8px;
            margin-top: 8px;
            font-size: 12px;
            color: #666;
        }
        
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .preview-panel {
                position: relative;
                top: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- PANNEAU DE CONFIGURATION -->
        <div class="panel">
            <div class="header">
                <div class="logo">RUBI<span class="logo-x">X</span></div>
                <h1>G√©n√©rateur Intelligent</h1>
            </div>
            
            <div class="info-box">
                üí° <strong>Nouvelle approche !</strong> Collez votre texte, r√©pondez √† quelques questions, et l'IA g√©n√®re automatiquement le meilleur design pour votre contenu.
            </div>
            
            <!-- √âTAPE 1: TEXTE -->
            <h2>üìù √âtape 1 : Votre contenu</h2>
            <div class="form-group">
                <label>Collez votre texte ici</label>
                <textarea id="contenu" placeholder="Exemple :
üöÄ Digital acquisition is at the heart of our strategy
In 2025, we launched our Lead Management Framework...

OU

Nos r√©sultats Q4 2024:
- +25% de croissance
- 98% satisfaction client
- Leader europ√©en"></textarea>
                <div class="tip-box">
                    üí° <strong>Astuce :</strong> Incluez emojis, titres, listes √† puces, chiffres... Je m'occupe de la mise en page !
                </div>
            </div>
            
            <!-- √âTAPE 2: ORIENTATION -->
            <h2>üìê √âtape 2 : Format de l'image</h2>
            <div class="radio-group">
                <div class="radio-option selected" onclick="selectOrientation('portrait')">
                    <input type="radio" name="orientation" id="portrait" checked>
                    <label for="portrait">
                        <span class="radio-label">üì±</span>
                        <span class="radio-text">Portrait<br>1080√ó1350<br>(LinkedIn/Instagram)</span>
                    </label>
                </div>
                <div class="radio-option" onclick="selectOrientation('paysage')">
                    <input type="radio" name="orientation" id="paysage">
                    <label for="paysage">
                        <span class="radio-label">üñ•Ô∏è</span>
                        <span class="radio-text">Paysage<br>1920√ó1080<br>(LinkedIn/Pr√©sentation)</span>
                    </label>
                </div>
            </div>
            
            <!-- √âTAPE 3: OBJECTIF -->
            <h2>üéØ √âtape 3 : Objectif de l'image</h2>
            <div class="form-group">
                <select id="objectif">
                    <option value="annoncer">Annoncer quelque chose (nouveau produit, service, √©v√©nement)</option>
                    <option value="resultats">Pr√©senter des r√©sultats / chiffres cl√©s / KPI</option>
                    <option value="processus">Expliquer un processus / m√©thode en √©tapes</option>
                    <option value="comparaison">Comparer avant/apr√®s ou deux situations</option>
                    <option value="conseils">Donner des conseils / bonnes pratiques</option>
                    <option value="citation">Mettre en avant une citation / message fort</option>
                    <option value="equipe">Pr√©senter une √©quipe / des personnes</option>
                    <option value="autre">Autre / Libre</option>
                </select>
            </div>
            
            <!-- √âTAPE 4: ID√âE VISUELLE (OPTIONNEL) -->
            <h2>üí° √âtape 4 : Id√©e visuelle (optionnel)</h2>
            <div class="form-group">
                <label>
                    Avez-vous une id√©e de design sp√©cifique ?
                    <span class="label-hint">Ex: "style olympique avec podium", "timeline horizontale", "cartes empil√©es"...</span>
                </label>
                <input type="text" id="idee_visuelle" placeholder="Laissez vide pour un design automatique optimal">
                <div class="tip-box">
                    üí° Si vous laissez vide, je choisis le meilleur design selon votre contenu et objectif
                </div>
            </div>
            
            <!-- √âTAPE 5: STYLE -->
            <h2>üé® √âtape 5 : Intensit√© visuelle</h2>
            <div class="form-group">
                <select id="style">
                    <option value="1">Minimaliste - √âpur√© et professionnel</option>
                    <option value="2" selected>√âquilibr√© - Illustrations et effets mod√©r√©s</option>
                    <option value="3">Dynamique - Maximum d'effets visuels</option>
                </select>
            </div>
            
            <button class="generate-btn" onclick="generateSmartImage()">
                ‚ú® G√©n√©rer l'image intelligente
            </button>
        </div>
        
        <!-- PANNEAU DE PR√âVISUALISATION -->
        <div class="panel preview-panel">
            <h2>üëÅÔ∏è Aper√ßu</h2>
            <div id="canvas-container">
                <canvas id="canvas" class="preview-canvas" width="1080" height="1350"></canvas>
            </div>
            <button class="download-btn" onclick="downloadImage()">
                ‚¨áÔ∏è T√©l√©charger l'image PNG
            </button>
            <div id="image-info" style="margin-top: 15px; text-align: center; color: #666; font-size: 13px;">
                üìê Format : 1080 √ó 1350 pixels (Portrait)
            </div>
        </div>
    </div>
    
    <script>
        let currentOrientation = 'portrait';
        let currentStyle = 2;
        
        function selectOrientation(orientation) {
            currentOrientation = orientation;
            document.querySelectorAll('.radio-option').forEach(el => el.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
            
            // Mettre √† jour le canvas
            const canvas = document.getElementById('canvas');
            if (orientation === 'portrait') {
                canvas.width = 1080;
                canvas.height = 1350;
                document.getElementById('image-info').textContent = 'üìê Format : 1080 √ó 1350 pixels (Portrait)';
            } else {
                canvas.width = 1920;
                canvas.height = 1080;
                document.getElementById('image-info').textContent = 'üìê Format : 1920 √ó 1080 pixels (Paysage)';
            }
        }
        
        function parseContent(text) {
            // Analyse intelligente du contenu
            const lines = text.split('\n').filter(l => l.trim());
            const parsed = {
                titre: '',
                soustitre: '',
                sections: [],
                listItems: [],
                hasEmojis: false,
                hasNumbers: false,
                hasBullets: false
            };
            
            // D√©tecter emojis
            const emojiRegex = /([\u{1F300}-\u{1F9FF}])/gu;
            parsed.hasEmojis = emojiRegex.test(text);
            
            // D√©tecter listes √† puces
            parsed.hasBullets = /^[\s]*[-‚Ä¢*]\s/.test(text);
            
            // D√©tecter chiffres/pourcentages
            parsed.hasNumbers = /\d+%|\+\d+|#\d+/.test(text);
            
            // Premi√®re ligne = titre (souvent avec emoji)
            if (lines.length > 0) {
                parsed.titre = lines[0];
            }
            
            // Deuxi√®me ligne = sous-titre si pas de bullet
            if (lines.length > 1 && !lines[1].match(/^[\s]*[-‚Ä¢*]\s/)) {
                parsed.soustitre = lines[1];
            }
            
            // Extraire les points/items
            lines.forEach((line, index) => {
                if (index === 0) return; // Skip titre
                if (index === 1 && parsed.soustitre) return; // Skip sous-titre
                
                const bulletMatch = line.match(/^[\s]*[-‚Ä¢*]\s(.+)/);
                if (bulletMatch) {
                    parsed.listItems.push(bulletMatch[1].trim());
                } else if (line.trim()) {
                    parsed.listItems.push(line.trim());
                }
            });
            
            return parsed;
        }
        
        function determineLayout(objectif, parsed, orientation) {
            // D√©cision intelligente du layout selon objectif et contenu
            
            if (objectif === 'citation') {
                return 'quote';
            }
            
            if (objectif === 'resultats' && parsed.hasNumbers) {
                return 'stats';
            }
            
            if (objectif === 'processus' || parsed.listItems.length >= 3) {
                return 'steps';
            }
            
            if (objectif === 'comparaison') {
                return 'comparison';
            }
            
            if (parsed.listItems.length > 0) {
                return 'list';
            }
            
            // D√©faut : hero simple
            return 'hero';
        }
        
        function generateSmartImage() {
            const contenu = document.getElementById('contenu').value;
            const objectif = document.getElementById('objectif').value;
            const ideeVisuelle = document.getElementById('idee_visuelle').value;
            currentStyle = parseInt(document.getElementById('style').value);
            
            if (!contenu.trim()) {
                alert('‚ö†Ô∏è Veuillez entrer du contenu !');
                return;
            }
            
            // Parser le contenu
            const parsed = parseContent(contenu);
            
            // D√©terminer le layout optimal
            const layout = determineLayout(objectif, parsed, currentOrientation);
            
            // G√©n√©rer l'image selon le layout
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // Couleurs Rubix
            const rubixBlue = '#051E50';
            const rubixYellow = '#FFD700';
            const white = '#FFFFFF';
            
            // Fond blanc
            ctx.fillStyle = white;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Appliquer le layout appropri√©
            switch(layout) {
                case 'quote':
                    drawQuoteLayout(ctx, parsed, canvas.width, canvas.height);
                    break;
                case 'stats':
                    drawStatsLayout(ctx, parsed, canvas.width, canvas.height);
                    break;
                case 'steps':
                    drawStepsLayout(ctx, parsed, canvas.width, canvas.height);
                    break;
                case 'comparison':
                    drawComparisonLayout(ctx, parsed, canvas.width, canvas.height);
                    break;
                case 'list':
                    drawListLayout(ctx, parsed, canvas.width, canvas.height);
                    break;
                default:
                    drawHeroLayout(ctx, parsed, canvas.width, canvas.height);
            }
            
            // Footer logo
            drawFooterLogo(ctx, canvas.width, canvas.height);
        }
        
        function drawQuoteLayout(ctx, parsed, width, height) {
            const rubixBlue = '#051E50';
            const rubixYellow = '#FFD700';
            
            // Fond d√©grad√©
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, rubixBlue);
            gradient.addColorStop(1, '#0a3d80');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Grande citation au centre
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 64px "Trebuchet MS", sans-serif';
            ctx.textAlign = 'center';
            
            const maxWidth = width - 160;
            const words = parsed.titre.split(' ');
            let line = '';
            let y = height / 2 - 100;
            
            words.forEach(word => {
                const testLine = line + word + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth) {
                    ctx.fillText(line, width/2, y);
                    line = word + ' ';
                    y += 80;
                } else {
                    line = testLine;
                }
            });
            ctx.fillText(line, width/2, y);
            
            // Guillemets d√©coratifs
            ctx.fillStyle = rubixYellow;
            ctx.font = '120px Arial';
            ctx.fillText('"', 100, height/2 - 150);
            ctx.fillText('"', width - 100, height/2 + 200);
        }
        
        function drawStatsLayout(ctx, parsed, width, height) {
            const rubixBlue = '#051E50';
            const rubixYellow = '#FFD700';
            
            // Header
            ctx.fillStyle = rubixBlue;
            ctx.fillRect(0, 0, width, 250);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 56px "Trebuchet MS", sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(parsed.titre, 60, 140);
            
            // Stats en grille
            const stats = parsed.listItems;
            const statsPerRow = currentOrientation === 'portrait' ? 2 : 3;
            const startY = 320;
            const cardWidth = (width - 140) / statsPerRow;
            const cardHeight = 280;
            
            stats.forEach((stat, index) => {
                const row = Math.floor(index / statsPerRow);
                const col = index % statsPerRow;
                const x = 70 + col * cardWidth;
                const y = startY + row * (cardHeight + 30);
                
                // Carte
                ctx.fillStyle = index % 2 === 0 ? '#e8f4ff' : '#fffbf0';
                drawRoundedRect(ctx, x, y, cardWidth - 30, cardHeight, 20);
                
                // Bordure
                ctx.strokeStyle = index % 2 === 0 ? rubixBlue : rubixYellow;
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Extraire chiffre si pr√©sent
                const numberMatch = stat.match(/(\+?\d+%?)/);
                if (numberMatch) {
                    ctx.fillStyle = rubixYellow;
                    ctx.font = 'bold 72px "Trebuchet MS", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(numberMatch[1], x + cardWidth/2 - 15, y + 120);
                    
                    const label = stat.replace(numberMatch[1], '').trim();
                    ctx.fillStyle = rubixBlue;
                    ctx.font = '24px "Trebuchet MS", sans-serif';
                    wrapText(ctx, label, x + cardWidth/2 - 15, y + 180, cardWidth - 60, 32);
                } else {
                    ctx.fillStyle = rubixBlue;
                    ctx.font = 'bold 28px "Trebuchet MS", sans-serif';
                    ctx.textAlign = 'center';
                    wrapText(ctx, stat, x + cardWidth/2 - 15, y + cardHeight/2, cardWidth - 60, 36);
                }
            });
        }
        
        function drawStepsLayout(ctx, parsed, width, height) {
            const rubixBlue = '#051E50';
            const rubixYellow = '#FFD700';
            
            // Titre
            ctx.fillStyle = rubixBlue;
            ctx.font = 'bold 56px "Trebuchet MS", sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(parsed.titre, 60, 100);
            
            // Timeline horizontale pour paysage, verticale pour portrait
            if (currentOrientation === 'paysage') {
                // Timeline horizontale
                const stepWidth = (width - 200) / parsed.listItems.length;
                parsed.listItems.forEach((item, index) => {
                    const x = 100 + index * stepWidth;
                    const y = height / 2;
                    
                    // Cercle num√©ro
                    ctx.fillStyle = index === parsed.listItems.length - 1 ? rubixYellow : rubixBlue;
                    ctx.beginPath();
                    ctx.arc(x + stepWidth/2, y, 50, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 48px "Trebuchet MS", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText((index + 1).toString(), x + stepWidth/2, y + 18);
                    
                    // Texte
                    ctx.fillStyle = rubixBlue;
                    ctx.font = '20px "Trebuchet MS", sans-serif';
                    wrapText(ctx, item, x + stepWidth/2, y + 120, stepWidth - 40, 28);
                    
                    // Fl√®che
                    if (index < parsed.listItems.length - 1) {
                        ctx.strokeStyle = '#cccccc';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(x + stepWidth/2 + 50, y);
                        ctx.lineTo(x + stepWidth/2 + stepWidth - 50, y);
                        ctx.stroke();
                        
                        // Pointe fl√®che
                        ctx.fillStyle = '#cccccc';
                        ctx.beginPath();
                        ctx.moveTo(x + stepWidth/2 + stepWidth - 50, y);
                        ctx.lineTo(x + stepWidth/2 + stepWidth - 65, y - 10);
                        ctx.lineTo(x + stepWidth/2 + stepWidth - 65, y + 10);
                        ctx.fill();
                    }
                });
            } else {
                // Timeline verticale
                const startY = 200;
                const stepHeight = Math.min(280, (height - startY - 150) / parsed.listItems.length);
                
                parsed.listItems.forEach((item, index) => {
                    const y = startY + index * stepHeight;
                    
                    // Cercle num√©ro
                    ctx.fillStyle = index === parsed.listItems.length - 1 ? rubixYellow : rubixBlue;
                    ctx.beginPath();
                    ctx.arc(140, y + 50, 45, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 42px "Trebuchet MS", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText((index + 1).toString(), 140, y + 65);
                    
                    // Carte texte
                    ctx.fillStyle = '#f8f9fa';
                    drawRoundedRect(ctx, 220, y + 10, width - 280, stepHeight - 40, 15);
                    
                    ctx.fillStyle = rubixBlue;
                    ctx.font = '24px "Trebuchet MS", sans-serif';
                    ctx.textAlign = 'left';
                    wrapText(ctx, item, 250, y + 60, width - 340, 32);
                    
                    // Ligne verticale
                    if (index < parsed.listItems.length - 1) {
                        ctx.strokeStyle = '#cccccc';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(140, y + 95);
                        ctx.lineTo(140, y + stepHeight - 5);
                        ctx.stroke();
                    }
                });
            }
        }
        
        function drawComparisonLayout(ctx, parsed, width, height) {
            const rubixBlue = '#051E50';
            const rubixYellow = '#FFD700';
            
            // Titre
            ctx.fillStyle = rubixBlue;
            ctx.font = 'bold 56px "Trebuchet MS", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(parsed.titre, width/2, 100);
            
            // Deux colonnes : Avant / Apr√®s
            const colWidth = (width - 180) / 2;
            const startY = 200;
            
            // Colonne AVANT (gris)
            ctx.fillStyle = '#f5f5f5';
            drawRoundedRect(ctx, 60, startY, colWidth, height - startY - 180, 20);
            
            ctx.fillStyle = '#707070';
            ctx.font = 'bold 42px "Trebuchet MS", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('‚ùå AVANT', 60 + colWidth/2, startY + 70);
            
            // Items avant (premi√®re moiti√©)
            const midPoint = Math.ceil(parsed.listItems.length / 2);
            let itemY = startY + 140;
            for (let i = 0; i < midPoint && i < parsed.listItems.length; i++) {
                ctx.fillStyle = '#707070';
                ctx.font = '22px "Trebuchet MS", sans-serif';
                ctx.textAlign = 'left';
                wrapText(ctx, '‚Ä¢ ' + parsed.listItems[i], 90, itemY, colWidth - 60, 32);
                itemY += 80;
            }
            
            // Colonne APR√àS (jaune)
            ctx.fillStyle = '#fffbf0';
            drawRoundedRect(ctx, 60 + colWidth + 60, startY, colWidth, height - startY - 180, 20);
            
            ctx.fillStyle = rubixBlue;
            ctx.font = 'bold 42px "Trebuchet MS", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('‚úÖ APR√àS', 60 + colWidth + 60 + colWidth/2, startY + 70);
            
            // Items apr√®s (deuxi√®me moiti√©)
            itemY = startY + 140;
            for (let i = midPoint; i < parsed.listItems.length; i++) {
                ctx.fillStyle = rubixBlue;
                ctx.font = '22px "Trebuchet MS", sans-serif';
                ctx.textAlign = 'left';
                wrapText(ctx, '‚úì ' + parsed.listItems[i], 90 + colWidth + 60, itemY, colWidth - 60, 32);
                itemY += 80;
            }
        }
        
        function drawListLayout(ctx, parsed, width, height) {
            const rubixBlue = '#051E50';
            const rubixYellow = '#FFD700';
            
            // Header avec fond
            ctx.fillStyle = rubixBlue;
            ctx.fillRect(0, 0, width, 230);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 52px "Trebuchet MS", sans-serif';
            ctx.textAlign = 'left';
            wrapText(ctx, parsed.titre, 60, 100, width - 120, 60);
            
            // Liste avec puces stylis√©es
            const startY = 280;
            const itemHeight = 90;
            
            parsed.listItems.forEach((item, index) => {
                const y = startY + index * itemHeight;
                
                // Puce jaune
                ctx.fillStyle = rubixYellow;
                ctx.beginPath();
                ctx.arc(100, y + 25, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Texte
                ctx.fillStyle = rubixBlue;
                ctx.font = '26px "Trebuchet MS", sans-serif';
                ctx.textAlign = 'left';
                wrapText(ctx, item, 140, y + 15, width - 200, 36);
            });
        }
        
        function drawHeroLayout(ctx, parsed, width, height) {
            const rubixBlue = '#051E50';
            const rubixYellow = '#FFD700';
            
            // Fond d√©grad√© subtil
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            // √âl√©ments d√©coratifs
            if (currentStyle >= 2) {
                ctx.fillStyle = rubixYellow;
                ctx.globalAlpha = 0.1;
                ctx.beginPath();
                ctx.arc(width - 150, 150, 200, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Titre principal centr√©
            ctx.fillStyle = rubixBlue;
            ctx.font = 'bold 68px "Trebuchet MS", sans-serif';
            ctx.textAlign = 'center';
            wrapText(ctx, parsed.titre, width/2, height/3, width - 120, 80);
            
            // Sous-titre si pr√©sent
            if (parsed.soustitre) {
                ctx.fillStyle = '#666666';
                ctx.font = '32px "Trebuchet MS", sans-serif';
                wrapText(ctx, parsed.soustitre, width/2, height/2 - 50, width - 160, 44);
            }
            
            // Points cl√©s en bas
            if (parsed.listItems.length > 0) {
                const itemsPerRow = currentOrientation === 'portrait' ? 1 : 3;
                const itemWidth = width / itemsPerRow - 80;
                const startY = height - 350;
                
                parsed.listItems.slice(0, 3).forEach((item, index) => {
                    const col = index % itemsPerRow;
                    const row = Math.floor(index / itemsPerRow);
                    const x = 60 + col * (itemWidth + 40);
                    const y = startY + row * 120;
                    
                    // Ic√¥ne
                    ctx.fillStyle = rubixYellow;
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 30, 20, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = rubixBlue;
                    ctx.font = 'bold 28px "Trebuchet MS", sans-serif';
                    ctx.fillText('‚úì', x + 22, y + 40);
                    
                    // Texte
                    ctx.font = '22px "Trebuchet MS", sans-serif';
                    ctx.textAlign = 'left';
                    wrapText(ctx, item, x + 70, y + 20, itemWidth - 70, 30);
                });
            }
        }
        
        function drawFooterLogo(ctx, width, height) {
            const rubixBlue = '#051E50';
            const rubixYellow = '#FFD700';
            
            const footerY = height - 80;
            const logoX = width - 200;
            
            // X icon
            ctx.strokeStyle = rubixYellow;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(logoX - 20, footerY - 5);
            ctx.lineTo(logoX + 20, footerY + 35);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(logoX - 20, footerY + 35);
            ctx.lineTo(logoX + 20, footerY - 5);
            ctx.stroke();
            
            // Logo text
            ctx.fillStyle = rubixBlue;
            ctx.font = 'bold 28px "Trebuchet MS", sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('RUBI', logoX + 35, footerY + 25);
            ctx.fillStyle = rubixYellow;
            ctx.fillText('X', logoX + 110, footerY + 25);
        }
        
        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
            ctx.fill();
        }
        
        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let currentY = y;
            
            words.forEach((word, index) => {
                const testLine = line + word + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && index > 0) {
                    ctx.fillText(line, x, currentY);
                    line = word + ' ';
                    currentY += lineHeight;
                } else {
                    line = testLine;
                }
            });
            ctx.fillText(line, x, currentY);
        }
        
        function downloadImage() {
            const canvas = document.getElementById('canvas');
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0,10);
            link.download = `rubix_${currentOrientation}_${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
    </script>
</body>
</html>
